<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fuego (XFG) Price Chart</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    body, html { margin:0; padding:0; background:#000; color:#fff; font-family:sans-serif; }
    #chart { width:100%; height:600px; }
    h1 { text-align:center; margin:16px 0; }
    .debug { position: absolute; top: 0; right: 0; background: rgba(0,0,0,0.8); color: #0f0; padding: 10px; font-family: monospace; font-size: 12px; max-width: 300px; z-index: 1000; }
  </style>
</head>
<body>
  <h1>Fuego (XFG) Price Chart (USD)</h1>
  <div id="chart"></div>
  <div class="debug" id="debug">Loading...</div>
  <script>
  
  function log(msg) {
      console.log(msg);
      const debugEl = document.getElementById('debug');
      if (debugEl) {
          debugEl.innerHTML += msg + '<br>';
      }
  }

  // Convert line data to candlestick OHLC data
  function convertToCandlestickData(priceData) {
      if (priceData.length === 0) return [];
      
      // Group data by day to create daily candles
      const dailyData = new Map();
      
      priceData.forEach(item => {
          const dayTimestamp = Math.floor(item.time / 86400) * 86400; // Round to start of day
          
          if (!dailyData.has(dayTimestamp)) {
              dailyData.set(dayTimestamp, {
                  time: dayTimestamp,
                  open: item.value,
                  high: item.value,
                  low: item.value,
                  close: item.value,
                  prices: [item.value]
              });
          } else {
              const candle = dailyData.get(dayTimestamp);
              candle.high = Math.max(candle.high, item.value);
              candle.low = Math.min(candle.low, item.value);
              candle.close = item.value; // Last price of the day becomes close
              candle.prices.push(item.value);
          }
      });
      
      // Convert to array and ensure proper OHLC structure
      const candlestickData = Array.from(dailyData.values()).map(candle => {
          // If we have multiple prices for the day, use first as open, last as close
          if (candle.prices.length > 1) {
              candle.open = candle.prices[0];
              candle.close = candle.prices[candle.prices.length - 1];
          }
          
          // Remove the prices array as it's not needed for the chart
          delete candle.prices;
          
          return candle;
      }).sort((a, b) => a.time - b.time);
      
      log(`✓ Converted to candlestick data: ${candlestickData.length} candles`);
      return candlestickData;
  }
  
  async function fetchPriceData() {
      try {
          log('Starting data fetch...');
          
          // Try multiple potential URLs for XFG/BTC historical data
          const githubUrls = [
              'https://raw.githubusercontent.com/XGoldDragon/market-data/master/drglbtc-fcb.json',
              'https://raw.githubusercontent.com/XGoldDragon/market-data/main/drglbtc-fcb.json',
              'https://api.github.com/repos/XGoldDragon/market-data/contents/drglbtc-fcb.json'
          ];
          
          let xfgBtcData = null;
          for (let url of githubUrls) {
              try {
                  log(`Trying GitHub URL: ${url}`);
                  const response = await fetch(url);
                  if (response.ok) {
                      const data = await response.json();
                      // Handle GitHub API response (base64 encoded)
                      if (data.content && data.encoding === 'base64') {
                          xfgBtcData = JSON.parse(atob(data.content));
                      } else {
                          xfgBtcData = data;
                      }
                      log(`✓ GitHub data loaded: ${Object.keys(xfgBtcData).length} entries`);
                      break;
                  } else {
                      log(`✗ GitHub URL failed: ${response.status}`);
                  }
              } catch (e) {
                  log(`✗ GitHub URL error: ${e.message}`);
              }
          }
          
          // Fetch recent XFG/USD data from CoinPaprika for latest prices
          log('Fetching recent CoinPaprika data...');
          let recentData = [];
          try {
              const recentResponse = await fetch('https://graphsv2.coinpaprika.com/currency/data/xfg-fango/30d/?quote=usd');
              if (recentResponse.ok) {
                  const recent = await recentResponse.json();
                  log(`CoinPaprika response: ${JSON.stringify(recent).substring(0, 200)}`);
                  if (recent[0]?.price) {
                      recentData = recent[0].price.map(([timestamp, price]) => ({
                          time: Math.floor(timestamp / 1000),
                          value: price
                      }));
                      log(`✓ Recent data loaded: ${recentData.length} points`);
                  }
              } else {
                  log(`✗ CoinPaprika failed: ${recentResponse.status}`);
              }
          } catch (e) {
              log(`✗ CoinPaprika error: ${e.message}`);
          }
          
          // If we have historical XFG/BTC data, convert it to XFG/USD
          let historicalData = [];
          if (xfgBtcData && Object.keys(xfgBtcData).length > 0) {
              log('Fetching BTC/USD price history...');
              try {
                  const btcResponse = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=max&interval=daily');
                  if (btcResponse.ok) {
                      const btcData = await btcResponse.json();
                      log(`✓ BTC data loaded: ${btcData.prices?.length} points`);
                      
                      // Create BTC price lookup map
                      const btcPriceMap = new Map();
                      btcData.prices.forEach(([timestamp, price]) => {
                          const dayKey = Math.floor(timestamp / (1000 * 60 * 60 * 24));
                          btcPriceMap.set(dayKey, price);
                      });
                      
                      // Convert XFG/BTC to XFG/USD
                      historicalData = Object.entries(xfgBtcData).map(([dateStr, xfgBtcPrice]) => {
                          const timestamp = new Date(dateStr).getTime() / 1000;
                          const dayKey = Math.floor(timestamp / (60 * 60 * 24));
                          const btcUsdPrice = btcPriceMap.get(dayKey);
                          
                          if (btcUsdPrice && xfgBtcPrice > 0) {
                              return {
                                  time: Math.floor(timestamp),
                                  value: xfgBtcPrice * btcUsdPrice
                              };
                          }
                          return null;
                      }).filter(item => item && !isNaN(item.value));
                      
                      log(`✓ Converted historical data: ${historicalData.length} points`);
                  } else {
                      log(`✗ BTC price fetch failed: ${btcResponse.status}`);
                  }
              } catch (e) {
                  log(`✗ BTC price error: ${e.message}`);
              }
          }
          
          // Combine historical and recent data, remove duplicates
          const allData = [...historicalData, ...recentData];
          const uniqueData = allData.reduce((acc, current) => {
              const existing = acc.find(item => item.time === current.time);
              if (!existing) {
                  acc.push(current);
              }
              return acc;
          }, []);
          
          // Sort by timestamp
          const sortedData = uniqueData.sort((a, b) => a.time - b.time);
          log(`✓ Final dataset: ${sortedData.length} points`);
          
          if (sortedData.length === 0) {
              throw new Error('No data available from any source');
          }
          
          return sortedData;
          
      } catch (error) {
          log(`✗ Main error: ${error.message}`);
          // Fallback to recent data only if everything else fails
          try {
              log('Attempting final fallback...');
              const fallbackResponse = await fetch('https://graphsv2.coinpaprika.com/currency/data/xfg-fango/30d/?quote=usd');
              if (fallbackResponse.ok) {
                  const fallback = await fallbackResponse.json();
                  if (fallback[0]?.price) {
                      const fallbackData = fallback[0].price.map(([timestamp, price]) => ({
                          time: Math.floor(timestamp / 1000),
                          value: price
                      }));
                      log(`✓ Fallback data: ${fallbackData.length} points`);
                      return fallbackData;
                  }
              }
          } catch (fallbackError) {
              log(`✗ Fallback failed: ${fallbackError.message}`);
          }
          return [];
      }
  }

  async function initChart() {
      try {
          log('Initializing candlestick chart...');
          
          if (!window.LightweightCharts?.createChart) {
              throw new Error('Lightweight Charts library not loaded');
          }

          const chart = LightweightCharts.createChart(document.getElementById('chart'), {
              layout: {
                  backgroundColor: '#000000',
                  textColor: 'rgba(255, 255, 255, 0.9)'
              },
              grid: {
                  vertLines: { color: '#333' },
                  horzLines: { color: '#333' }
              },
              width: document.getElementById('chart').clientWidth,
              height: 600
          });

          // Add candlestick series instead of line series
          const candlestickSeries = chart.addCandlestickSeries({
              upColor: '#22e1e4',
              downColor: '#ff6b6b',
              borderDownColor: '#ff6b6b',
              borderUpColor: '#22e1e4',
              wickDownColor: '#ff6b6b',
              wickUpColor: '#22e1e4'
          });

          // Volume histogram in its own price scale
          const volumeSeries = chart.addHistogramSeries({
              color: '#666',
              priceFormat: { type: 'volume' },
              priceScaleId: 'volume'
          });

          // Position volume scale beneath the main candlestick chart
          chart.priceScale('volume').applyOptions({
              scaleMargins: { top: 0.8, bottom: 0 }
          });

          const priceData = await fetchPriceData();
          
          if (priceData.length === 0) {
              throw new Error('No price data available');
          }
          
          // Convert line data to candlestick OHLC data
          const candlestickData = convertToCandlestickData(priceData);
          
          const volumeData = candlestickData.map((d, i) => {
              const prevClose = i > 0 ? candlestickData[i-1].close : d.open;
              const priceChange = Math.abs(d.close - prevClose);
              const candleRange = d.high - d.low;
              return {
                  time: d.time,
                  value: (priceChange + candleRange) * 500000, // Volume approximation based on price movement
                  color: d.close >= d.open ? 'rgba(34,225,228,0.3)' : 'rgba(255,107,107,0.3)'
              };
          });

          log(`✓ Setting chart data: ${candlestickData.length} candles, ${volumeData.length} volume points`);
          candlestickSeries.setData(candlestickData);
          volumeSeries.setData(volumeData);
          chart.timeScale().fitContent();

          chart.applyOptions({
              timeScale: {
                  timeVisible: true,
                  secondsVisible: false,
                  borderColor: '#666',
              }
          });
          
          log('✓ Candlestick chart initialized successfully');

      } catch (error) {
          log(`✗ Chart error: ${error.message}`);
          document.getElementById('chart').innerHTML = `
              <div style="color: #ffa500; text-align: center; padding: 2rem;">
                  <p>Chart temporarily unavailable</p>
                  <small>${error.message}</small>
                  <br><br>
                  <button onclick="location.reload()" style="background:#22e1e4; color:#000; border:none; padding:8px 16px; cursor:pointer;">Retry</button>
              </div>
          `;
      }
  }

  window.addEventListener('load', initChart);
  </script>
</body>
</html> 